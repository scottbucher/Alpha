import { MikroORM } from '@mikro-orm/core';
import { MongoDriver } from '@mikro-orm/mongodb';
import { Client } from 'discord.js';
import { DateTime } from 'luxon';
import { createRequire } from 'node:module';

import { Job } from './index.js';
import { XpMultiplier } from '../database/entities/event-data.js';
import { EventData, GuildData } from '../database/entities/index.js';
import { EventType } from '../enums/index.js';
import { Logger } from '../services/index.js';
import { TimeUtils } from '../utils/index.js';

const require = createRequire(import.meta.url);
let Config = require('../../config/config.json');
let Logs = require('../../lang/logs.json');

export class GenerateXpEventsJob extends Job {
    public name = 'Generate XP Events';
    // Run every Sunday at 11:59 PM
    public schedule: string = Config.jobs.generateXpEvents.schedule;
    public log: boolean = Config.jobs.generateXpEvents.log;
    public runOnce: boolean = Config.jobs.generateXpEvents.runOnce;
    public initialDelaySecs: number = Config.jobs.generateXpEvents.initialDelaySecs;

    // Base probability for XP weekends, compensated for 1 guaranteed anniversary per 52 weeks
    // Original: 15% chance per weekend
    // Adjusted: (15% * 52 weekends) / 51 non-anniversary weekends â‰ˆ 15.29%
    // This ensures the expected number of regular XP events remains constant despite the guaranteed anniversary
    private readonly XP_WEEKEND_CHANCE = (0.15 * 52) / 51;

    constructor(
        private client: Client,
        private orm: MikroORM<MongoDriver>
    ) {
        super();
    }

    public async run(): Promise<void> {
        let em = this.orm.em.fork();
        let guildIds = this.client.guilds.cache.map(guild => guild.id);

        try {
            // Get active Discord guilds

            // Get database guilds that are still active
            const guilds = await em.find(
                GuildData,
                { discordId: { $in: guildIds } },
                {
                    populate: ['eventDatas'],
                }
            );

            for (const guild of guilds) {
                try {
                    await this.generateEventsForGuild(guild, em);
                } catch (error) {
                    Logger.error(
                        Logs.error.generateXpEventsError.replace('{GUILD_ID}', guild.discordId),
                        {
                            error: error.message,
                        }
                    );
                }
            }

            await em.flush();
        } catch (error) {
            Logger.error(Logs.error.generateXpEventsJobError, {
                error: error.message,
            });
        }
    }

    private async generateEventsForGuild(guild: GuildData, em: any): Promise<void> {
        let now = TimeUtils.getNowForGuild(guild);

        // Get the next 4 weekends
        const weekends = this.getNextWeekends(now, 4);

        // Filter out weekends that already have any type of event
        const existingEvents = guild.eventDatas
            .getItems()
            .filter(
                event =>
                    (event.eventType === EventType.INCREASED_XP_WEEKEND ||
                        event.eventType === EventType.NO_INCREASED_XP_WEEKEND ||
                        event.eventType === EventType.ANNIVERSARY_XP_WEEKEND) &&
                    event.autoGenerated
            );

        const newWeekends = weekends.filter(
            weekend => !this.hasExistingEvent(existingEvents, weekend.start, weekend.end)
        );

        // Check if any of the new weekends is the anniversary weekend
        const anniversaryInfo = this.findAnniversaryWeekend(guild, newWeekends, now);

        // Generate events for new weekends
        for (const weekend of newWeekends) {
            // Check if this is the anniversary weekend
            const isAnniversaryWeekend =
                anniversaryInfo &&
                weekend.start.equals(anniversaryInfo.weekend.start) &&
                weekend.end.equals(anniversaryInfo.weekend.end);

            if (isAnniversaryWeekend) {
                // Guaranteed anniversary XP event
                const multiplier = this.calculateAnniversaryMultiplier(anniversaryInfo.years);

                const event = new EventData(
                    em.getReference(GuildData, guild.id),
                    EventType.ANNIVERSARY_XP_WEEKEND,
                    weekend.start.toISO(),
                    weekend.end.toISO()
                );

                event.autoGenerated = true;
                event.xpProperties.multiplier = multiplier;

                em.persist(event);
                guild.eventDatas.add(event);

                Logger.info(
                    Logs.info.anniversaryXpEventGenerated
                        .replace('{MULTIPLIER}', multiplier.toString())
                        .replace('{START_TIME}', weekend.start.toISO())
                        .replace('{END_TIME}', weekend.end.toISO())
                        .replace('{GUILD_ID}', guild.discordId)
                );
            } else if (Math.random() < this.XP_WEEKEND_CHANCE) {
                // ~15.29% chance for a regular XP event (compensated for guaranteed anniversary)
                const multiplier = this.determineMultiplier();

                const event = new EventData(
                    em.getReference(GuildData, guild.id),
                    EventType.INCREASED_XP_WEEKEND,
                    weekend.start.toISO(),
                    weekend.end.toISO()
                );

                event.autoGenerated = true;
                event.xpProperties.multiplier = multiplier;

                em.persist(event);
                guild.eventDatas.add(event);

                Logger.info(
                    Logs.info.xpEventGenerated
                        .replace('{MULTIPLIER}', multiplier.toString())
                        .replace('{START_TIME}', weekend.start.toISO())
                        .replace('{END_TIME}', weekend.end.toISO())
                        .replace('{GUILD_ID}', guild.discordId)
                );
            } else {
                // Create a NO_INCREASED_XP_WEEKEND entry to track that we checked this weekend
                const noEventMarker = new EventData(
                    em.getReference(GuildData, guild.id),
                    EventType.NO_INCREASED_XP_WEEKEND,
                    weekend.start.toISO(),
                    weekend.end.toISO()
                );

                noEventMarker.autoGenerated = true;

                em.persist(noEventMarker);
                guild.eventDatas.add(noEventMarker);
            }
        }
    }

    private determineMultiplier(): XpMultiplier {
        const rand = Math.random();
        if (rand < 0.85) return 2; // 85% chance
        if (rand < 0.95) return 3; // 10% chance
        return 4; // 5% chance
    }

    private calculateAnniversaryMultiplier(years: number): XpMultiplier {
        // Base: 1 + 0.25x per year
        // Every 5th year: +0.75x extra bonus
        // Examples: Year 1 = 1.25x, Year 2 = 1.5x, Year 5 = 3x, Year 10 = 5x
        const baseMultiplier = 1 + 0.25 * years;
        const bonusMultiplier = Math.floor(years / 5) * 0.75;
        return baseMultiplier + bonusMultiplier;
    }

    private findAnniversaryWeekend(
        guild: GuildData,
        weekends: Array<{ start: DateTime; end: DateTime }>,
        now: DateTime
    ): { weekend: { start: DateTime; end: DateTime }; years: number } | null {
        // Get the Discord guild to access creation date
        const discordGuild = this.client.guilds.cache.get(guild.discordId);
        if (!discordGuild) {
            return null;
        }

        // Convert guild creation date to the guild's time zone
        const creationDate = DateTime.fromJSDate(discordGuild.createdAt, {
            zone: guild.generalSettings.timeZone || 'UTC',
        });

        // Calculate this year's anniversary
        const thisYearAnniversary = creationDate.set({
            year: now.year,
        });

        // If the anniversary has already passed this year, look at next year's
        const upcomingAnniversary =
            thisYearAnniversary < now
                ? thisYearAnniversary.plus({ years: 1 })
                : thisYearAnniversary;

        // Calculate how many years old the server will be on this anniversary
        const years = upcomingAnniversary.year - creationDate.year;

        // Skip if this would be a 0-year anniversary (server is less than 1 year old)
        if (years < 1) {
            return null;
        }

        // Find the weekend that contains or follows the anniversary
        for (const weekend of weekends) {
            // Check if anniversary falls within the weekend
            if (upcomingAnniversary >= weekend.start && upcomingAnniversary < weekend.end) {
                return { weekend, years };
            }

            // Check if anniversary is before the weekend (use the next weekend if mid-week)
            if (upcomingAnniversary < weekend.start) {
                // Check if anniversary is within the same week (before Friday)
                const daysUntilWeekend = weekend.start.diff(upcomingAnniversary, 'days').days;
                // If anniversary is within 7 days before the weekend start, use this weekend
                if (daysUntilWeekend <= 7) {
                    return { weekend, years };
                }
            }
        }

        return null;
    }

    private getNextWeekends(
        from: DateTime,
        count: number
    ): Array<{ start: DateTime; end: DateTime }> {
        const weekends = [];
        let current = from;

        while (weekends.length < count) {
            // Find next Friday
            while (current.weekday !== 5) {
                // 5 = Friday
                current = current.plus({ days: 1 });
            }

            // Start time is Friday 6 PM
            const startTime = current.set({ hour: 18, minute: 0, second: 0, millisecond: 0 });

            // End time is Sunday night at midnight (Monday 00:00)
            // Need to add 3 days from Friday to get to Monday
            const endTime = current.plus({ days: 3 }).set({
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0,
            });

            weekends.push({ start: startTime, end: endTime });

            // Move to next week
            current = current.plus({ days: 7 });
        }

        return weekends;
    }

    private hasExistingEvent(events: EventData[], startTime: DateTime, endTime: DateTime): boolean {
        return events.some(event => {
            // Get the time zone from the comparing events (assuming they're all in the same zone)
            const timeZone = startTime.zone.name;

            // Parse the event times with the proper time zone
            const eventStart = DateTime.fromISO(event.timeProperties.startTime, { zone: timeZone });
            const eventEnd = DateTime.fromISO(event.timeProperties.endTime, { zone: timeZone });

            // Check if the time periods overlap (exclusive)
            return !(eventEnd <= startTime || eventStart >= endTime);
        });
    }
}
